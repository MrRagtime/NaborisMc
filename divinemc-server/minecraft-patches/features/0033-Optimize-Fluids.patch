From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: NONPLAYT <76615486+NONPLAYT@users.noreply.github.com>
Date: Fri, 31 Jan 2025 22:40:54 +0300
Subject: [PATCH] Optimize Fluids


diff --git a/net/minecraft/world/level/block/LiquidBlock.java b/net/minecraft/world/level/block/LiquidBlock.java
index 283e5fc879fd9869205549d66b3b99662ec56564..8aa9dac64bcfb81fdfebd1327a0f18bbc104b9d8 100644
--- a/net/minecraft/world/level/block/LiquidBlock.java
+++ b/net/minecraft/world/level/block/LiquidBlock.java
@@ -199,6 +199,7 @@ public class LiquidBlock extends Block implements BucketPickup {
                     Block block = level.getFluidState(pos).isSource() ? Blocks.OBSIDIAN : Blocks.COBBLESTONE;
                     // CraftBukkit start
                     if (org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(level, pos, block.defaultBlockState(), 3)) {
+                        level.setBlock(pos, block.defaultBlockState(), 3); // DivineMC - Optimize Fluids
                         this.fizz(level, pos);
                     }
                     // CraftBukkit end
diff --git a/net/minecraft/world/level/material/FlowingFluid.java b/net/minecraft/world/level/material/FlowingFluid.java
index 18f008dceff896a405970afe157321105d55405f..1de0ef32b6519cad10c8ebf0ed328b6773bcb3ff 100644
--- a/net/minecraft/world/level/material/FlowingFluid.java
+++ b/net/minecraft/world/level/material/FlowingFluid.java
@@ -200,6 +200,7 @@ public abstract class FlowingFluid extends Fluid {
                 BlockPos blockPos = pos.relative(direction);
                 final BlockState blockStateIfLoaded = level.getBlockStateIfLoaded(blockPos); // Paper - Prevent chunk loading from fluid flowing
                 if (blockStateIfLoaded == null) continue; // Paper - Prevent chunk loading from fluid flowing
+                if (!shouldSpreadLiquid(level, blockPos, blockStateIfLoaded)) continue; // DivineMC - Optimize Fluids
                 // CraftBukkit start
                 org.bukkit.block.Block source = org.bukkit.craftbukkit.block.CraftBlock.at(level, pos);
                 org.bukkit.event.block.BlockFromToEvent event = new org.bukkit.event.block.BlockFromToEvent(source, org.bukkit.craftbukkit.block.CraftBlock.notchToBlockFace(direction));
@@ -214,6 +215,39 @@ public abstract class FlowingFluid extends Fluid {
         }
     }
 
+    // DivineMC start - Optimize Fluids
+    private boolean shouldSpreadLiquid(Level level, BlockPos pos, BlockState state) {
+        if (state.is(Blocks.LAVA)) {
+            boolean isSoulSoil = level.getBlockState(pos.below()).is(Blocks.SOUL_SOIL);
+
+            for (Direction direction : net.minecraft.world.level.block.LiquidBlock.POSSIBLE_FLOW_DIRECTIONS) {
+                BlockPos blockPos = pos.relative(direction.getOpposite());
+                if (level.getFluidState(blockPos).is(net.minecraft.tags.FluidTags.WATER)) {
+                    Block block = level.getFluidState(pos).isSource() ? Blocks.OBSIDIAN : Blocks.COBBLESTONE;
+                    if (org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(level, pos, block.defaultBlockState(), 3)) {
+                        this.fizz(level, pos);
+                        level.setBlock(pos, block.defaultBlockState(), 3);
+                    }
+                    return false;
+                }
+
+                if (isSoulSoil && level.getBlockState(blockPos).is(Blocks.BLUE_ICE)) {
+                    if (org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(level, pos, Blocks.BASALT.defaultBlockState(), 3)) {
+                        this.fizz(level, pos);
+                    }
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    private void fizz(LevelAccessor level, BlockPos pos) {
+        level.levelEvent(1501, pos, 0);
+    }
+    // DivineMC end - Optimize Fluids
+
     protected FluidState getNewLiquid(ServerLevel level, BlockPos pos, BlockState state) {
         int i = 0;
         int i1 = 0;
@@ -343,33 +377,46 @@ public abstract class FlowingFluid extends Fluid {
 
     protected abstract void beforeDestroyingBlock(LevelAccessor level, BlockPos pos, BlockState state);
 
+    // DivineMC start - Optimize Fluids
     protected int getSlopeDistance(LevelReader level, BlockPos pos, int depth, Direction direction, BlockState state, FlowingFluid.SpreadContext spreadContext) {
-        int i = 1000;
+        int slopeFindDistance = this.getSlopeFindDistance(level);
+        int minDistance = slopeFindDistance;
 
-        for (Direction direction1 : Direction.Plane.HORIZONTAL) {
-            if (direction1 != direction) {
-                BlockPos blockPos = pos.relative(direction1);
-                BlockState blockState = spreadContext.getBlockStateIfLoaded(blockPos); // Paper - Prevent chunk loading from fluid flowing
-                if (blockState == null) continue; // Paper - Prevent chunk loading from fluid flowing
-                FluidState fluidState = blockState.getFluidState();
-                if (this.canPassThrough(level, this.getFlowing(), pos, state, direction1, blockPos, blockState, fluidState)) {
-                    if (spreadContext.isHole(blockPos)) {
-                        return depth;
+        java.util.Deque<net.minecraft.world.level.material.FlowingFluid.Node> stack = new java.util.ArrayDeque<>();
+        stack.push(new Node(pos, depth, direction));
+
+        while (!stack.isEmpty()) {
+            Node current = stack.pop();
+            BlockPos currentPos = current.pos;
+            int currentDepth = current.depth;
+            Direction fromDirection = current.direction;
+
+            for (Direction dir : Direction.Plane.HORIZONTAL) {
+                if (dir == fromDirection) continue;
+
+                BlockPos neighborPos = currentPos.relative(dir);
+                BlockState neighborState = spreadContext.getBlockStateIfLoaded(neighborPos);
+                if (neighborState == null) continue; // Prevent chunk loading
+
+                FluidState fluidState = neighborState.getFluidState();
+                if (this.canPassThrough(level, this.getFlowing(), currentPos, state, dir, neighborPos, neighborState, fluidState)) {
+                    if (spreadContext.isHole(neighborPos)) {
+                        return currentDepth;
                     }
 
-                    if (depth < this.getSlopeFindDistance(level)) {
-                        int slopeDistance = this.getSlopeDistance(level, blockPos, depth + 1, direction1.getOpposite(), blockState, spreadContext);
-                        if (slopeDistance < i) {
-                            i = slopeDistance;
-                        }
+                    if (currentDepth + 1 < slopeFindDistance && currentDepth + 1 < minDistance) {
+                        stack.push(new Node(neighborPos, currentDepth + 1, dir.getOpposite()));
                     }
                 }
             }
         }
 
-        return i;
+        return minDistance;
     }
 
+    private record Node(BlockPos pos, int depth, Direction direction) { }
+    // DivineMC end - Optimize Fluids
+
     boolean isWaterHole(BlockGetter level, BlockPos pos, BlockState state, BlockPos belowPos, BlockState belowState) {
         return canPassThroughWall(Direction.DOWN, level, pos, state, belowPos, belowState)
             && (belowState.getFluidState().getType().isSame(this) || canHoldFluid(level, belowPos, belowState, this.getFlowing()));
diff --git a/net/minecraft/world/level/material/LavaFluid.java b/net/minecraft/world/level/material/LavaFluid.java
index b7da2efaa784ef470029410be3e2359c5bf6dace..2d845b09abe3354f0999b117e78ffd00c41e8924 100644
--- a/net/minecraft/world/level/material/LavaFluid.java
+++ b/net/minecraft/world/level/material/LavaFluid.java
@@ -237,6 +237,7 @@ public abstract class LavaFluid extends FlowingFluid {
                     // CraftBukkit end
                 }
 
+                level.setBlock(pos, Blocks.STONE.defaultBlockState(), 3); // DivineMC - Optimize Fluids
                 this.fizz(level, pos);
                 return;
             }
